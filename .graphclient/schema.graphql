schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Query {
  swapFactory(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapFactory
  swapFactories(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapFactory_orderBy
    orderDirection: OrderDirection
    where: SwapFactory_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapFactory!]!
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  pair(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pair
  pairs(
    skip: Int = 0
    first: Int = 100
    orderBy: Pair_orderBy
    orderDirection: OrderDirection
    where: Pair_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Pair!]!
  pairHourData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PairHourData
  pairHourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: PairHourData_orderBy
    orderDirection: OrderDirection
    where: PairHourData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PairHourData!]!
  pairDayData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PairDayData
  pairDayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: PairDayData_orderBy
    orderDirection: OrderDirection
    where: PairDayData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PairDayData!]!
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  liquidityPosition(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPosition
  liquidityPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPosition_orderBy
    orderDirection: OrderDirection
    where: LiquidityPosition_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPosition!]!
  bundle(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bundle
  bundles(
    skip: Int = 0
    first: Int = 100
    orderBy: Bundle_orderBy
    orderDirection: OrderDirection
    where: Bundle_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Bundle!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  claimMaxGas(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClaimMaxGas
  claimMaxGas_collection(
    skip: Int = 0
    first: Int = 100
    orderBy: ClaimMaxGas_orderBy
    orderDirection: OrderDirection
    where: ClaimMaxGas_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ClaimMaxGas!]!
  gasManagerTransferred(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GasManagerTransferred
  gasManagerTransferreds(
    skip: Int = 0
    first: Int = 100
    orderBy: GasManagerTransferred_orderBy
    orderDirection: OrderDirection
    where: GasManagerTransferred_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GasManagerTransferred!]!
  ownershipTransferred(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnershipTransferred
  ownershipTransferreds(
    skip: Int = 0
    first: Int = 100
    orderBy: OwnershipTransferred_orderBy
    orderDirection: OrderDirection
    where: OwnershipTransferred_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OwnershipTransferred!]!
  setForceUnstakeFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetForceUnstakeFee
  setForceUnstakeFees(
    skip: Int = 0
    first: Int = 100
    orderBy: SetForceUnstakeFee_orderBy
    orderDirection: OrderDirection
    where: SetForceUnstakeFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetForceUnstakeFee!]!
  setMaxLockupDays(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetMaxLockupDays
  setMaxLockupDays_collection(
    skip: Int = 0
    first: Int = 100
    orderBy: SetMaxLockupDays_orderBy
    orderDirection: OrderDirection
    where: SetMaxLockupDays_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetMaxLockupDays!]!
  setMinLockupDays(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetMinLockupDays
  setMinLockupDays_collection(
    skip: Int = 0
    first: Int = 100
    orderBy: SetMinLockupDays_orderBy
    orderDirection: OrderDirection
    where: SetMinLockupDays_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetMinLockupDays!]!
  setOutETHVault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetOutETHVault
  setOutETHVaults(
    skip: Int = 0
    first: Int = 100
    orderBy: SetOutETHVault_orderBy
    orderDirection: OrderDirection
    where: SetOutETHVault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetOutETHVault!]!
  extendLockTime(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExtendLockTime
  extendLockTimes(
    skip: Int = 0
    first: Int = 100
    orderBy: ExtendLockTime_orderBy
    orderDirection: OrderDirection
    where: ExtendLockTime_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ExtendLockTime!]!
  stakeRETH(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeRETH
  stakeRETHs(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeRETH_orderBy
    orderDirection: OrderDirection
    where: StakeRETH_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeRETH!]!
  unstake(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Unstake
  unstakes(
    skip: Int = 0
    first: Int = 100
    orderBy: Unstake_orderBy
    orderDirection: OrderDirection
    where: Unstake_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Unstake!]!
  withdrawYield(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WithdrawYield
  withdrawYields(
    skip: Int = 0
    first: Int = 100
    orderBy: WithdrawYield_orderBy
    orderDirection: OrderDirection
    where: WithdrawYield_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WithdrawYield!]!
}

type Subscription {
  swapFactory(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapFactory
  swapFactories(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapFactory_orderBy
    orderDirection: OrderDirection
    where: SwapFactory_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapFactory!]!
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  pair(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pair
  pairs(
    skip: Int = 0
    first: Int = 100
    orderBy: Pair_orderBy
    orderDirection: OrderDirection
    where: Pair_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Pair!]!
  pairHourData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PairHourData
  pairHourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: PairHourData_orderBy
    orderDirection: OrderDirection
    where: PairHourData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PairHourData!]!
  pairDayData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PairDayData
  pairDayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: PairDayData_orderBy
    orderDirection: OrderDirection
    where: PairDayData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PairDayData!]!
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  liquidityPosition(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPosition
  liquidityPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPosition_orderBy
    orderDirection: OrderDirection
    where: LiquidityPosition_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPosition!]!
  bundle(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bundle
  bundles(
    skip: Int = 0
    first: Int = 100
    orderBy: Bundle_orderBy
    orderDirection: OrderDirection
    where: Bundle_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Bundle!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  claimMaxGas(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClaimMaxGas
  claimMaxGas_collection(
    skip: Int = 0
    first: Int = 100
    orderBy: ClaimMaxGas_orderBy
    orderDirection: OrderDirection
    where: ClaimMaxGas_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ClaimMaxGas!]!
  gasManagerTransferred(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GasManagerTransferred
  gasManagerTransferreds(
    skip: Int = 0
    first: Int = 100
    orderBy: GasManagerTransferred_orderBy
    orderDirection: OrderDirection
    where: GasManagerTransferred_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GasManagerTransferred!]!
  ownershipTransferred(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OwnershipTransferred
  ownershipTransferreds(
    skip: Int = 0
    first: Int = 100
    orderBy: OwnershipTransferred_orderBy
    orderDirection: OrderDirection
    where: OwnershipTransferred_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OwnershipTransferred!]!
  setForceUnstakeFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetForceUnstakeFee
  setForceUnstakeFees(
    skip: Int = 0
    first: Int = 100
    orderBy: SetForceUnstakeFee_orderBy
    orderDirection: OrderDirection
    where: SetForceUnstakeFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetForceUnstakeFee!]!
  setMaxLockupDays(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetMaxLockupDays
  setMaxLockupDays_collection(
    skip: Int = 0
    first: Int = 100
    orderBy: SetMaxLockupDays_orderBy
    orderDirection: OrderDirection
    where: SetMaxLockupDays_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetMaxLockupDays!]!
  setMinLockupDays(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetMinLockupDays
  setMinLockupDays_collection(
    skip: Int = 0
    first: Int = 100
    orderBy: SetMinLockupDays_orderBy
    orderDirection: OrderDirection
    where: SetMinLockupDays_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetMinLockupDays!]!
  setOutETHVault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetOutETHVault
  setOutETHVaults(
    skip: Int = 0
    first: Int = 100
    orderBy: SetOutETHVault_orderBy
    orderDirection: OrderDirection
    where: SetOutETHVault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetOutETHVault!]!
  extendLockTime(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExtendLockTime
  extendLockTimes(
    skip: Int = 0
    first: Int = 100
    orderBy: ExtendLockTime_orderBy
    orderDirection: OrderDirection
    where: ExtendLockTime_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ExtendLockTime!]!
  stakeRETH(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeRETH
  stakeRETHs(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeRETH_orderBy
    orderDirection: OrderDirection
    where: StakeRETH_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeRETH!]!
  unstake(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Unstake
  unstakes(
    skip: Int = 0
    first: Int = 100
    orderBy: Unstake_orderBy
    orderDirection: OrderDirection
    where: Unstake_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Unstake!]!
  withdrawYield(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WithdrawYield
  withdrawYields(
    skip: Int = 0
    first: Int = 100
    orderBy: WithdrawYield_orderBy
    orderDirection: OrderDirection
    where: WithdrawYield_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WithdrawYield!]!
}

enum Aggregation_interval {
  hour
  day
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

type Bundle {
  id: Bytes!
  ethPrice: BigDecimal!
}

input Bundle_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  ethPrice: BigDecimal
  ethPrice_not: BigDecimal
  ethPrice_gt: BigDecimal
  ethPrice_lt: BigDecimal
  ethPrice_gte: BigDecimal
  ethPrice_lte: BigDecimal
  ethPrice_in: [BigDecimal!]
  ethPrice_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Bundle_filter]
  or: [Bundle_filter]
}

enum Bundle_orderBy {
  id
  ethPrice
}

scalar Bytes

"""
8 bytes signed integer

"""
scalar Int8

type LiquidityPosition {
  id: String!
  user: User!
  pair: Pair!
  liquidityTokenBalance: BigDecimal!
}

input LiquidityPosition_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: User_filter
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  pair_: Pair_filter
  liquidityTokenBalance: BigDecimal
  liquidityTokenBalance_not: BigDecimal
  liquidityTokenBalance_gt: BigDecimal
  liquidityTokenBalance_lt: BigDecimal
  liquidityTokenBalance_gte: BigDecimal
  liquidityTokenBalance_lte: BigDecimal
  liquidityTokenBalance_in: [BigDecimal!]
  liquidityTokenBalance_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LiquidityPosition_filter]
  or: [LiquidityPosition_filter]
}

enum LiquidityPosition_orderBy {
  id
  user
  user__id
  user__usdSwapped
  pair
  pair__id
  pair__token0Price
  pair__token1Price
  pair__reserve0
  pair__reserve1
  pair__totalSupply
  pair__volumeToken0
  pair__volumeToken1
  pair__volumeUSD
  pair__reserveETH
  pair__reserveUSD
  pair__liquidityProviderCount
  liquidityTokenBalance
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Pair {
  id: Bytes!
  token0: Token!
  token0Price: BigDecimal!
  token1: Token!
  token1Price: BigDecimal!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigDecimal!
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
  reserveETH: BigDecimal!
  reserveUSD: BigDecimal!
  pairHourData(skip: Int = 0, first: Int = 100, orderBy: PairHourData_orderBy, orderDirection: OrderDirection, where: PairHourData_filter): [PairHourData!]!
  LiquidityPositions(skip: Int = 0, first: Int = 100, orderBy: LiquidityPosition_orderBy, orderDirection: OrderDirection, where: LiquidityPosition_filter): [LiquidityPosition!]!
  liquidityProviderCount: BigInt!
}

type PairDayData {
  id: String!
  date: Int!
  pairAddress: Bytes!
  token0: Token!
  token1: Token!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigDecimal
  reserveUSD: BigDecimal!
  dailyVolumeToken0: BigDecimal!
  dailyVolumeToken1: BigDecimal!
  dailyVolumeUSD: BigDecimal!
  dailyTxns: BigInt!
}

input PairDayData_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  pairAddress: Bytes
  pairAddress_not: Bytes
  pairAddress_gt: Bytes
  pairAddress_lt: Bytes
  pairAddress_gte: Bytes
  pairAddress_lte: Bytes
  pairAddress_in: [Bytes!]
  pairAddress_not_in: [Bytes!]
  pairAddress_contains: Bytes
  pairAddress_not_contains: Bytes
  token0: String
  token0_not: String
  token0_gt: String
  token0_lt: String
  token0_gte: String
  token0_lte: String
  token0_in: [String!]
  token0_not_in: [String!]
  token0_contains: String
  token0_contains_nocase: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_: Token_filter
  token1: String
  token1_not: String
  token1_gt: String
  token1_lt: String
  token1_gte: String
  token1_lte: String
  token1_in: [String!]
  token1_not_in: [String!]
  token1_contains: String
  token1_contains_nocase: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_: Token_filter
  reserve0: BigDecimal
  reserve0_not: BigDecimal
  reserve0_gt: BigDecimal
  reserve0_lt: BigDecimal
  reserve0_gte: BigDecimal
  reserve0_lte: BigDecimal
  reserve0_in: [BigDecimal!]
  reserve0_not_in: [BigDecimal!]
  reserve1: BigDecimal
  reserve1_not: BigDecimal
  reserve1_gt: BigDecimal
  reserve1_lt: BigDecimal
  reserve1_gte: BigDecimal
  reserve1_lte: BigDecimal
  reserve1_in: [BigDecimal!]
  reserve1_not_in: [BigDecimal!]
  totalSupply: BigDecimal
  totalSupply_not: BigDecimal
  totalSupply_gt: BigDecimal
  totalSupply_lt: BigDecimal
  totalSupply_gte: BigDecimal
  totalSupply_lte: BigDecimal
  totalSupply_in: [BigDecimal!]
  totalSupply_not_in: [BigDecimal!]
  reserveUSD: BigDecimal
  reserveUSD_not: BigDecimal
  reserveUSD_gt: BigDecimal
  reserveUSD_lt: BigDecimal
  reserveUSD_gte: BigDecimal
  reserveUSD_lte: BigDecimal
  reserveUSD_in: [BigDecimal!]
  reserveUSD_not_in: [BigDecimal!]
  dailyVolumeToken0: BigDecimal
  dailyVolumeToken0_not: BigDecimal
  dailyVolumeToken0_gt: BigDecimal
  dailyVolumeToken0_lt: BigDecimal
  dailyVolumeToken0_gte: BigDecimal
  dailyVolumeToken0_lte: BigDecimal
  dailyVolumeToken0_in: [BigDecimal!]
  dailyVolumeToken0_not_in: [BigDecimal!]
  dailyVolumeToken1: BigDecimal
  dailyVolumeToken1_not: BigDecimal
  dailyVolumeToken1_gt: BigDecimal
  dailyVolumeToken1_lt: BigDecimal
  dailyVolumeToken1_gte: BigDecimal
  dailyVolumeToken1_lte: BigDecimal
  dailyVolumeToken1_in: [BigDecimal!]
  dailyVolumeToken1_not_in: [BigDecimal!]
  dailyVolumeUSD: BigDecimal
  dailyVolumeUSD_not: BigDecimal
  dailyVolumeUSD_gt: BigDecimal
  dailyVolumeUSD_lt: BigDecimal
  dailyVolumeUSD_gte: BigDecimal
  dailyVolumeUSD_lte: BigDecimal
  dailyVolumeUSD_in: [BigDecimal!]
  dailyVolumeUSD_not_in: [BigDecimal!]
  dailyTxns: BigInt
  dailyTxns_not: BigInt
  dailyTxns_gt: BigInt
  dailyTxns_lt: BigInt
  dailyTxns_gte: BigInt
  dailyTxns_lte: BigInt
  dailyTxns_in: [BigInt!]
  dailyTxns_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PairDayData_filter]
  or: [PairDayData_filter]
}

enum PairDayData_orderBy {
  id
  date
  pairAddress
  token0
  token0__id
  token0__symbol
  token0__name
  token0__decimals
  token0__derivedETH
  token1
  token1__id
  token1__symbol
  token1__name
  token1__decimals
  token1__derivedETH
  reserve0
  reserve1
  totalSupply
  reserveUSD
  dailyVolumeToken0
  dailyVolumeToken1
  dailyVolumeUSD
  dailyTxns
}

type PairHourData {
  id: Bytes!
  hourStartUnix: Int!
  pair: Pair!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigDecimal
  reserveUSD: BigDecimal!
  hourlyVolumeToken0: BigDecimal!
  hourlyVolumeToken1: BigDecimal!
  hourlyVolumeUSD: BigDecimal!
  hourlyTxns: BigInt!
}

input PairHourData_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  hourStartUnix: Int
  hourStartUnix_not: Int
  hourStartUnix_gt: Int
  hourStartUnix_lt: Int
  hourStartUnix_gte: Int
  hourStartUnix_lte: Int
  hourStartUnix_in: [Int!]
  hourStartUnix_not_in: [Int!]
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  pair_: Pair_filter
  reserve0: BigDecimal
  reserve0_not: BigDecimal
  reserve0_gt: BigDecimal
  reserve0_lt: BigDecimal
  reserve0_gte: BigDecimal
  reserve0_lte: BigDecimal
  reserve0_in: [BigDecimal!]
  reserve0_not_in: [BigDecimal!]
  reserve1: BigDecimal
  reserve1_not: BigDecimal
  reserve1_gt: BigDecimal
  reserve1_lt: BigDecimal
  reserve1_gte: BigDecimal
  reserve1_lte: BigDecimal
  reserve1_in: [BigDecimal!]
  reserve1_not_in: [BigDecimal!]
  totalSupply: BigDecimal
  totalSupply_not: BigDecimal
  totalSupply_gt: BigDecimal
  totalSupply_lt: BigDecimal
  totalSupply_gte: BigDecimal
  totalSupply_lte: BigDecimal
  totalSupply_in: [BigDecimal!]
  totalSupply_not_in: [BigDecimal!]
  reserveUSD: BigDecimal
  reserveUSD_not: BigDecimal
  reserveUSD_gt: BigDecimal
  reserveUSD_lt: BigDecimal
  reserveUSD_gte: BigDecimal
  reserveUSD_lte: BigDecimal
  reserveUSD_in: [BigDecimal!]
  reserveUSD_not_in: [BigDecimal!]
  hourlyVolumeToken0: BigDecimal
  hourlyVolumeToken0_not: BigDecimal
  hourlyVolumeToken0_gt: BigDecimal
  hourlyVolumeToken0_lt: BigDecimal
  hourlyVolumeToken0_gte: BigDecimal
  hourlyVolumeToken0_lte: BigDecimal
  hourlyVolumeToken0_in: [BigDecimal!]
  hourlyVolumeToken0_not_in: [BigDecimal!]
  hourlyVolumeToken1: BigDecimal
  hourlyVolumeToken1_not: BigDecimal
  hourlyVolumeToken1_gt: BigDecimal
  hourlyVolumeToken1_lt: BigDecimal
  hourlyVolumeToken1_gte: BigDecimal
  hourlyVolumeToken1_lte: BigDecimal
  hourlyVolumeToken1_in: [BigDecimal!]
  hourlyVolumeToken1_not_in: [BigDecimal!]
  hourlyVolumeUSD: BigDecimal
  hourlyVolumeUSD_not: BigDecimal
  hourlyVolumeUSD_gt: BigDecimal
  hourlyVolumeUSD_lt: BigDecimal
  hourlyVolumeUSD_gte: BigDecimal
  hourlyVolumeUSD_lte: BigDecimal
  hourlyVolumeUSD_in: [BigDecimal!]
  hourlyVolumeUSD_not_in: [BigDecimal!]
  hourlyTxns: BigInt
  hourlyTxns_not: BigInt
  hourlyTxns_gt: BigInt
  hourlyTxns_lt: BigInt
  hourlyTxns_gte: BigInt
  hourlyTxns_lte: BigInt
  hourlyTxns_in: [BigInt!]
  hourlyTxns_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PairHourData_filter]
  or: [PairHourData_filter]
}

enum PairHourData_orderBy {
  id
  hourStartUnix
  pair
  pair__id
  pair__token0Price
  pair__token1Price
  pair__reserve0
  pair__reserve1
  pair__totalSupply
  pair__volumeToken0
  pair__volumeToken1
  pair__volumeUSD
  pair__reserveETH
  pair__reserveUSD
  pair__liquidityProviderCount
  reserve0
  reserve1
  totalSupply
  reserveUSD
  hourlyVolumeToken0
  hourlyVolumeToken1
  hourlyVolumeUSD
  hourlyTxns
}

input Pair_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  token0: String
  token0_not: String
  token0_gt: String
  token0_lt: String
  token0_gte: String
  token0_lte: String
  token0_in: [String!]
  token0_not_in: [String!]
  token0_contains: String
  token0_contains_nocase: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_: Token_filter
  token0Price: BigDecimal
  token0Price_not: BigDecimal
  token0Price_gt: BigDecimal
  token0Price_lt: BigDecimal
  token0Price_gte: BigDecimal
  token0Price_lte: BigDecimal
  token0Price_in: [BigDecimal!]
  token0Price_not_in: [BigDecimal!]
  token1: String
  token1_not: String
  token1_gt: String
  token1_lt: String
  token1_gte: String
  token1_lte: String
  token1_in: [String!]
  token1_not_in: [String!]
  token1_contains: String
  token1_contains_nocase: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_: Token_filter
  token1Price: BigDecimal
  token1Price_not: BigDecimal
  token1Price_gt: BigDecimal
  token1Price_lt: BigDecimal
  token1Price_gte: BigDecimal
  token1Price_lte: BigDecimal
  token1Price_in: [BigDecimal!]
  token1Price_not_in: [BigDecimal!]
  reserve0: BigDecimal
  reserve0_not: BigDecimal
  reserve0_gt: BigDecimal
  reserve0_lt: BigDecimal
  reserve0_gte: BigDecimal
  reserve0_lte: BigDecimal
  reserve0_in: [BigDecimal!]
  reserve0_not_in: [BigDecimal!]
  reserve1: BigDecimal
  reserve1_not: BigDecimal
  reserve1_gt: BigDecimal
  reserve1_lt: BigDecimal
  reserve1_gte: BigDecimal
  reserve1_lte: BigDecimal
  reserve1_in: [BigDecimal!]
  reserve1_not_in: [BigDecimal!]
  totalSupply: BigDecimal
  totalSupply_not: BigDecimal
  totalSupply_gt: BigDecimal
  totalSupply_lt: BigDecimal
  totalSupply_gte: BigDecimal
  totalSupply_lte: BigDecimal
  totalSupply_in: [BigDecimal!]
  totalSupply_not_in: [BigDecimal!]
  volumeToken0: BigDecimal
  volumeToken0_not: BigDecimal
  volumeToken0_gt: BigDecimal
  volumeToken0_lt: BigDecimal
  volumeToken0_gte: BigDecimal
  volumeToken0_lte: BigDecimal
  volumeToken0_in: [BigDecimal!]
  volumeToken0_not_in: [BigDecimal!]
  volumeToken1: BigDecimal
  volumeToken1_not: BigDecimal
  volumeToken1_gt: BigDecimal
  volumeToken1_lt: BigDecimal
  volumeToken1_gte: BigDecimal
  volumeToken1_lte: BigDecimal
  volumeToken1_in: [BigDecimal!]
  volumeToken1_not_in: [BigDecimal!]
  volumeUSD: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_lt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_not_in: [BigDecimal!]
  reserveETH: BigDecimal
  reserveETH_not: BigDecimal
  reserveETH_gt: BigDecimal
  reserveETH_lt: BigDecimal
  reserveETH_gte: BigDecimal
  reserveETH_lte: BigDecimal
  reserveETH_in: [BigDecimal!]
  reserveETH_not_in: [BigDecimal!]
  reserveUSD: BigDecimal
  reserveUSD_not: BigDecimal
  reserveUSD_gt: BigDecimal
  reserveUSD_lt: BigDecimal
  reserveUSD_gte: BigDecimal
  reserveUSD_lte: BigDecimal
  reserveUSD_in: [BigDecimal!]
  reserveUSD_not_in: [BigDecimal!]
  pairHourData_: PairHourData_filter
  LiquidityPositions_: LiquidityPosition_filter
  liquidityProviderCount: BigInt
  liquidityProviderCount_not: BigInt
  liquidityProviderCount_gt: BigInt
  liquidityProviderCount_lt: BigInt
  liquidityProviderCount_gte: BigInt
  liquidityProviderCount_lte: BigInt
  liquidityProviderCount_in: [BigInt!]
  liquidityProviderCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Pair_filter]
  or: [Pair_filter]
}

enum Pair_orderBy {
  id
  token0
  token0__id
  token0__symbol
  token0__name
  token0__decimals
  token0__derivedETH
  token0Price
  token1
  token1__id
  token1__symbol
  token1__name
  token1__decimals
  token1__derivedETH
  token1Price
  reserve0
  reserve1
  totalSupply
  volumeToken0
  volumeToken1
  volumeUSD
  reserveETH
  reserveUSD
  pairHourData
  LiquidityPositions
  liquidityProviderCount
}

type SwapFactory {
  id: Bytes!
  pairCount: Int!
  totalVolumeETH: BigDecimal!
  totalLiquidityETH: BigDecimal!
  totalVolumeUSD: BigDecimal!
  untrackedVolumeUSD: BigDecimal!
  totalLiquidityUSD: BigDecimal!
  txCount: BigInt!
}

input SwapFactory_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  pairCount: Int
  pairCount_not: Int
  pairCount_gt: Int
  pairCount_lt: Int
  pairCount_gte: Int
  pairCount_lte: Int
  pairCount_in: [Int!]
  pairCount_not_in: [Int!]
  totalVolumeETH: BigDecimal
  totalVolumeETH_not: BigDecimal
  totalVolumeETH_gt: BigDecimal
  totalVolumeETH_lt: BigDecimal
  totalVolumeETH_gte: BigDecimal
  totalVolumeETH_lte: BigDecimal
  totalVolumeETH_in: [BigDecimal!]
  totalVolumeETH_not_in: [BigDecimal!]
  totalLiquidityETH: BigDecimal
  totalLiquidityETH_not: BigDecimal
  totalLiquidityETH_gt: BigDecimal
  totalLiquidityETH_lt: BigDecimal
  totalLiquidityETH_gte: BigDecimal
  totalLiquidityETH_lte: BigDecimal
  totalLiquidityETH_in: [BigDecimal!]
  totalLiquidityETH_not_in: [BigDecimal!]
  totalVolumeUSD: BigDecimal
  totalVolumeUSD_not: BigDecimal
  totalVolumeUSD_gt: BigDecimal
  totalVolumeUSD_lt: BigDecimal
  totalVolumeUSD_gte: BigDecimal
  totalVolumeUSD_lte: BigDecimal
  totalVolumeUSD_in: [BigDecimal!]
  totalVolumeUSD_not_in: [BigDecimal!]
  untrackedVolumeUSD: BigDecimal
  untrackedVolumeUSD_not: BigDecimal
  untrackedVolumeUSD_gt: BigDecimal
  untrackedVolumeUSD_lt: BigDecimal
  untrackedVolumeUSD_gte: BigDecimal
  untrackedVolumeUSD_lte: BigDecimal
  untrackedVolumeUSD_in: [BigDecimal!]
  untrackedVolumeUSD_not_in: [BigDecimal!]
  totalLiquidityUSD: BigDecimal
  totalLiquidityUSD_not: BigDecimal
  totalLiquidityUSD_gt: BigDecimal
  totalLiquidityUSD_lt: BigDecimal
  totalLiquidityUSD_gte: BigDecimal
  totalLiquidityUSD_lte: BigDecimal
  totalLiquidityUSD_in: [BigDecimal!]
  totalLiquidityUSD_not_in: [BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SwapFactory_filter]
  or: [SwapFactory_filter]
}

enum SwapFactory_orderBy {
  id
  pairCount
  totalVolumeETH
  totalLiquidityETH
  totalVolumeUSD
  untrackedVolumeUSD
  totalLiquidityUSD
  txCount
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type Token {
  id: Bytes!
  symbol: String!
  name: String!
  decimals: BigInt!
  derivedETH: BigDecimal!
}

input Token_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  derivedETH: BigDecimal
  derivedETH_not: BigDecimal
  derivedETH_gt: BigDecimal
  derivedETH_lt: BigDecimal
  derivedETH_gte: BigDecimal
  derivedETH_lte: BigDecimal
  derivedETH_in: [BigDecimal!]
  derivedETH_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  symbol
  name
  decimals
  derivedETH
}

type User {
  id: Bytes!
  liquidityPositions(skip: Int = 0, first: Int = 100, orderBy: LiquidityPosition_orderBy, orderDirection: OrderDirection, where: LiquidityPosition_filter): [LiquidityPosition!]
  usdSwapped: BigDecimal!
}

input User_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  liquidityPositions_: LiquidityPosition_filter
  usdSwapped: BigDecimal
  usdSwapped_not: BigDecimal
  usdSwapped_gt: BigDecimal
  usdSwapped_lt: BigDecimal
  usdSwapped_gte: BigDecimal
  usdSwapped_lte: BigDecimal
  usdSwapped_in: [BigDecimal!]
  usdSwapped_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [User_filter]
  or: [User_filter]
}

enum User_orderBy {
  id
  liquidityPositions
  usdSwapped
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

type ClaimMaxGas {
  id: Bytes!
  recipient: Bytes!
  gasAmount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input ClaimMaxGas_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  recipient: Bytes
  recipient_not: Bytes
  recipient_gt: Bytes
  recipient_lt: Bytes
  recipient_gte: Bytes
  recipient_lte: Bytes
  recipient_in: [Bytes!]
  recipient_not_in: [Bytes!]
  recipient_contains: Bytes
  recipient_not_contains: Bytes
  gasAmount: BigInt
  gasAmount_not: BigInt
  gasAmount_gt: BigInt
  gasAmount_lt: BigInt
  gasAmount_gte: BigInt
  gasAmount_lte: BigInt
  gasAmount_in: [BigInt!]
  gasAmount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ClaimMaxGas_filter]
  or: [ClaimMaxGas_filter]
}

enum ClaimMaxGas_orderBy {
  id
  recipient
  gasAmount
  blockNumber
  blockTimestamp
  transactionHash
}

type ExtendLockTime {
  id: Bytes!
  positionId: BigInt!
  extendDays: BigInt!
  newDeadLine: BigInt!
  mintedREY: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input ExtendLockTime_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  positionId: BigInt
  positionId_not: BigInt
  positionId_gt: BigInt
  positionId_lt: BigInt
  positionId_gte: BigInt
  positionId_lte: BigInt
  positionId_in: [BigInt!]
  positionId_not_in: [BigInt!]
  extendDays: BigInt
  extendDays_not: BigInt
  extendDays_gt: BigInt
  extendDays_lt: BigInt
  extendDays_gte: BigInt
  extendDays_lte: BigInt
  extendDays_in: [BigInt!]
  extendDays_not_in: [BigInt!]
  newDeadLine: BigInt
  newDeadLine_not: BigInt
  newDeadLine_gt: BigInt
  newDeadLine_lt: BigInt
  newDeadLine_gte: BigInt
  newDeadLine_lte: BigInt
  newDeadLine_in: [BigInt!]
  newDeadLine_not_in: [BigInt!]
  mintedREY: BigInt
  mintedREY_not: BigInt
  mintedREY_gt: BigInt
  mintedREY_lt: BigInt
  mintedREY_gte: BigInt
  mintedREY_lte: BigInt
  mintedREY_in: [BigInt!]
  mintedREY_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ExtendLockTime_filter]
  or: [ExtendLockTime_filter]
}

enum ExtendLockTime_orderBy {
  id
  positionId
  extendDays
  newDeadLine
  mintedREY
  blockNumber
  blockTimestamp
  transactionHash
}

type GasManagerTransferred {
  id: Bytes!
  previousGasManager: Bytes!
  newGasManager: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input GasManagerTransferred_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  previousGasManager: Bytes
  previousGasManager_not: Bytes
  previousGasManager_gt: Bytes
  previousGasManager_lt: Bytes
  previousGasManager_gte: Bytes
  previousGasManager_lte: Bytes
  previousGasManager_in: [Bytes!]
  previousGasManager_not_in: [Bytes!]
  previousGasManager_contains: Bytes
  previousGasManager_not_contains: Bytes
  newGasManager: Bytes
  newGasManager_not: Bytes
  newGasManager_gt: Bytes
  newGasManager_lt: Bytes
  newGasManager_gte: Bytes
  newGasManager_lte: Bytes
  newGasManager_in: [Bytes!]
  newGasManager_not_in: [Bytes!]
  newGasManager_contains: Bytes
  newGasManager_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [GasManagerTransferred_filter]
  or: [GasManagerTransferred_filter]
}

enum GasManagerTransferred_orderBy {
  id
  previousGasManager
  newGasManager
  blockNumber
  blockTimestamp
  transactionHash
}

type OwnershipTransferred {
  id: Bytes!
  previousOwner: Bytes!
  newOwner: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input OwnershipTransferred_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  previousOwner: Bytes
  previousOwner_not: Bytes
  previousOwner_gt: Bytes
  previousOwner_lt: Bytes
  previousOwner_gte: Bytes
  previousOwner_lte: Bytes
  previousOwner_in: [Bytes!]
  previousOwner_not_in: [Bytes!]
  previousOwner_contains: Bytes
  previousOwner_not_contains: Bytes
  newOwner: Bytes
  newOwner_not: Bytes
  newOwner_gt: Bytes
  newOwner_lt: Bytes
  newOwner_gte: Bytes
  newOwner_lte: Bytes
  newOwner_in: [Bytes!]
  newOwner_not_in: [Bytes!]
  newOwner_contains: Bytes
  newOwner_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OwnershipTransferred_filter]
  or: [OwnershipTransferred_filter]
}

enum OwnershipTransferred_orderBy {
  id
  previousOwner
  newOwner
  blockNumber
  blockTimestamp
  transactionHash
}

type SetForceUnstakeFee {
  id: Bytes!
  forceUnstakeFee: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input SetForceUnstakeFee_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  forceUnstakeFee: BigInt
  forceUnstakeFee_not: BigInt
  forceUnstakeFee_gt: BigInt
  forceUnstakeFee_lt: BigInt
  forceUnstakeFee_gte: BigInt
  forceUnstakeFee_lte: BigInt
  forceUnstakeFee_in: [BigInt!]
  forceUnstakeFee_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SetForceUnstakeFee_filter]
  or: [SetForceUnstakeFee_filter]
}

enum SetForceUnstakeFee_orderBy {
  id
  forceUnstakeFee
  blockNumber
  blockTimestamp
  transactionHash
}

type SetMaxLockupDays {
  id: Bytes!
  maxLockupDays: Int!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input SetMaxLockupDays_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  maxLockupDays: Int
  maxLockupDays_not: Int
  maxLockupDays_gt: Int
  maxLockupDays_lt: Int
  maxLockupDays_gte: Int
  maxLockupDays_lte: Int
  maxLockupDays_in: [Int!]
  maxLockupDays_not_in: [Int!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SetMaxLockupDays_filter]
  or: [SetMaxLockupDays_filter]
}

enum SetMaxLockupDays_orderBy {
  id
  maxLockupDays
  blockNumber
  blockTimestamp
  transactionHash
}

type SetMinLockupDays {
  id: Bytes!
  minLockupDays: Int!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input SetMinLockupDays_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  minLockupDays: Int
  minLockupDays_not: Int
  minLockupDays_gt: Int
  minLockupDays_lt: Int
  minLockupDays_gte: Int
  minLockupDays_lte: Int
  minLockupDays_in: [Int!]
  minLockupDays_not_in: [Int!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SetMinLockupDays_filter]
  or: [SetMinLockupDays_filter]
}

enum SetMinLockupDays_orderBy {
  id
  minLockupDays
  blockNumber
  blockTimestamp
  transactionHash
}

type SetOutETHVault {
  id: Bytes!
  outETHVault: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input SetOutETHVault_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  outETHVault: Bytes
  outETHVault_not: Bytes
  outETHVault_gt: Bytes
  outETHVault_lt: Bytes
  outETHVault_gte: Bytes
  outETHVault_lte: Bytes
  outETHVault_in: [Bytes!]
  outETHVault_not_in: [Bytes!]
  outETHVault_contains: Bytes
  outETHVault_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SetOutETHVault_filter]
  or: [SetOutETHVault_filter]
}

enum SetOutETHVault_orderBy {
  id
  outETHVault
  blockNumber
  blockTimestamp
  transactionHash
}

type StakeRETH {
  id: String!
  positionId: BigInt!
  newDeadLine: BigInt
  account: Bytes!
  amountInRETH: BigInt!
  amountInPETH: BigInt!
  amountInREY: BigInt!
  deadline: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input StakeRETH_filter {
  id: String
  id_not: String
  id_gt: String
  id_lt: String
  id_gte: String
  id_lte: String
  id_in: [String!]
  id_not_in: [String!]
  id_contains: String
  id_contains_nocase: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  positionId: BigInt
  positionId_not: BigInt
  positionId_gt: BigInt
  positionId_lt: BigInt
  positionId_gte: BigInt
  positionId_lte: BigInt
  positionId_in: [BigInt!]
  positionId_not_in: [BigInt!]
  newDeadLine: BigInt
  newDeadLine_not: BigInt
  newDeadLine_gt: BigInt
  newDeadLine_lt: BigInt
  newDeadLine_gte: BigInt
  newDeadLine_lte: BigInt
  newDeadLine_in: [BigInt!]
  newDeadLine_not_in: [BigInt!]
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  amountInRETH: BigInt
  amountInRETH_not: BigInt
  amountInRETH_gt: BigInt
  amountInRETH_lt: BigInt
  amountInRETH_gte: BigInt
  amountInRETH_lte: BigInt
  amountInRETH_in: [BigInt!]
  amountInRETH_not_in: [BigInt!]
  amountInPETH: BigInt
  amountInPETH_not: BigInt
  amountInPETH_gt: BigInt
  amountInPETH_lt: BigInt
  amountInPETH_gte: BigInt
  amountInPETH_lte: BigInt
  amountInPETH_in: [BigInt!]
  amountInPETH_not_in: [BigInt!]
  amountInREY: BigInt
  amountInREY_not: BigInt
  amountInREY_gt: BigInt
  amountInREY_lt: BigInt
  amountInREY_gte: BigInt
  amountInREY_lte: BigInt
  amountInREY_in: [BigInt!]
  amountInREY_not_in: [BigInt!]
  deadline: BigInt
  deadline_not: BigInt
  deadline_gt: BigInt
  deadline_lt: BigInt
  deadline_gte: BigInt
  deadline_lte: BigInt
  deadline_in: [BigInt!]
  deadline_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StakeRETH_filter]
  or: [StakeRETH_filter]
}

enum StakeRETH_orderBy {
  id
  positionId
  newDeadLine
  account
  amountInRETH
  amountInPETH
  amountInREY
  deadline
  blockNumber
  blockTimestamp
  transactionHash
}

type Unstake {
  id: Bytes!
  positionId: BigInt!
  amountInRETH: BigInt!
  burnedPETH: BigInt!
  burnedREY: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input Unstake_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  positionId: BigInt
  positionId_not: BigInt
  positionId_gt: BigInt
  positionId_lt: BigInt
  positionId_gte: BigInt
  positionId_lte: BigInt
  positionId_in: [BigInt!]
  positionId_not_in: [BigInt!]
  amountInRETH: BigInt
  amountInRETH_not: BigInt
  amountInRETH_gt: BigInt
  amountInRETH_lt: BigInt
  amountInRETH_gte: BigInt
  amountInRETH_lte: BigInt
  amountInRETH_in: [BigInt!]
  amountInRETH_not_in: [BigInt!]
  burnedPETH: BigInt
  burnedPETH_not: BigInt
  burnedPETH_gt: BigInt
  burnedPETH_lt: BigInt
  burnedPETH_gte: BigInt
  burnedPETH_lte: BigInt
  burnedPETH_in: [BigInt!]
  burnedPETH_not_in: [BigInt!]
  burnedREY: BigInt
  burnedREY_not: BigInt
  burnedREY_gt: BigInt
  burnedREY_lt: BigInt
  burnedREY_gte: BigInt
  burnedREY_lte: BigInt
  burnedREY_in: [BigInt!]
  burnedREY_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Unstake_filter]
  or: [Unstake_filter]
}

enum Unstake_orderBy {
  id
  positionId
  amountInRETH
  burnedPETH
  burnedREY
  blockNumber
  blockTimestamp
  transactionHash
}

type WithdrawYield {
  id: Bytes!
  account: Bytes!
  burnedREY: BigInt!
  yieldAmount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input WithdrawYield_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  burnedREY: BigInt
  burnedREY_not: BigInt
  burnedREY_gt: BigInt
  burnedREY_lt: BigInt
  burnedREY_gte: BigInt
  burnedREY_lte: BigInt
  burnedREY_in: [BigInt!]
  burnedREY_not_in: [BigInt!]
  yieldAmount: BigInt
  yieldAmount_not: BigInt
  yieldAmount_gt: BigInt
  yieldAmount_lt: BigInt
  yieldAmount_gte: BigInt
  yieldAmount_lte: BigInt
  yieldAmount_in: [BigInt!]
  yieldAmount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [WithdrawYield_filter]
  or: [WithdrawYield_filter]
}

enum WithdrawYield_orderBy {
  id
  account
  burnedREY
  yieldAmount
  blockNumber
  blockTimestamp
  transactionHash
}